
import pickle
import sys
import os

import pandas
import numpy
import emlearn
import m2cgen
import micromlgen

from sklearn.preprocessing import LabelEncoder

from emlearn.evaluate.size import get_program_size, check_build_tools
from emlearn.cgen import array_declare, constant_declare

from src.experiments.metrics import unique_features, feature_counts

def export_emlearn(estimator, name, inference='loadable', dtype='int16_t', **kwargs):

    c = emlearn.convert(estimator, dtype=dtype, **kwargs)
    code = c.save(name='model', inference=inference)    

    model_name = name
    code += f"""
    int {model_name}_predict(const {dtype} *f, int l) {{
        return eml_trees_predict(&{model_name}, (float *)f, l);
    }}"""

    return code

def export_m2cgen(estimator, name, **kwargs):

    code = m2cgen.export_to_c(estimator)

    # convert to double
    # call score

    return code

def export_micromlgen(estimator, name, **kwargs):

    code = micromlgen.port(estimator)

    # convert to float

    return code

def export_dummy(estimator, name, **kwargs):

    code = """
    int model_predict(const int16_t *features, int length) {

        double conv[length];
        for (int i=0; i<length; i++) {
            conv[i] = features[i];
        }

        const int out = (int)(conv[length-1] > 0.5f);
        return out;
    }
    """

    return code

def generate_test_data(X, Y):

    assert len(X) == len(Y)
    n_features = X.shape[1]

    # XXX: the cast to float is wrong. Will crash horribly during execution
    # Only works for size estimation

    # FIXME: implement inference for all types. emlearn, m2cgen, micromlgen

    code = '// Generated by compare_frameworks.py'
    X_flat = list(X.flatten(order='C'))
    code += '\n' + array_declare('testdata_values', values=X_flat, dtype='int16_t')

    code += '\n' + array_declare('testdata_labels', values=Y, dtype='int')
    code += '\n' + constant_declare('testdata_samples', len(X))
    code += '\n' + constant_declare('testdata_features', n_features)

    return code


def main():

    # Include test data. Features + expected label. Small set, say 10x per class
    # Inference code for each framework. One file per framework. Defines predict function
    # Test program. Macros to select a framework.
    #   Conditional include
    # Measure program size with no/dummy framework

    # One directory per model
    # Select N models, of various sizes, for each dataset

    out_dir = 'code'
    estimator_path = sys.argv[1]
    data_path = estimator_path.replace('.estimator.pickle', '.testdata.npz')

    testdata = numpy.load(data_path, allow_pickle=True)

    platforms = pandas.DataFrame.from_records([
        ('arm', 'Cortex-M0'),
        ('arm', 'Cortex-M4F'),
    ], columns=['platform', 'cpu'])

    with open(estimator_path, 'rb') as f:
        estimator = pickle.load(f)

    m = estimator

    counts = feature_counts(m)
    multi = counts[counts > 1]
    print('features used more than once', len(multi))

    features = unique_features(m)
    print('unique features', features)

    exporters = {
        'emlearn': export_emlearn,
        'm2cgen': export_m2cgen,
        'micromlgen': export_micromlgen,
        'none': export_dummy,
    }

    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    for k, exporter in exporters.items():

        p = os.path.join(out_dir, f'model_{k}.h')
        code = exporter(m, 'model')
        with open(p, 'w') as f:
            f.write(code)

    # FIXME: make sure transformation is correct wrt training
    encoder = LabelEncoder()
    X = testdata['X']
    Y = encoder.fit_transform(testdata['Y'])
    data = generate_test_data(X, Y)
    with open(os.path.join(out_dir, 'testdata.h'), 'w') as f:
        f.write(data)


    #data = get_program_size(test_program, platform=platform, mcu=mcu)

    #return pandas.Series(data)



if __name__ == '__main__':
    main()
