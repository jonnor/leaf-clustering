
import pickle
import sys
import os

import pandas
import numpy
import emlearn
import m2cgen
import micromlgen

from emlearn.evaluate.size import get_program_size, check_build_tools
from emlearn.cgen import array_declare, constant_declare

from src.experiments.metrics import unique_features, feature_counts

def export_emlearn(estimator, name, inference='loadable', dtype='int16_t', **kwargs):

    c = emlearn.convert(estimator, dtype=dtype, **kwargs)
    code = c.save(name='model', inference=inference)    

    model_name = name
    if inference == 'loadable':
        code += f"""\n
        int {model_name}_predict(const {dtype} *f, int l) {{
            return eml_trees_predict(&{model_name}, f, l);
        }}"""

    return code

def export_m2cgen(estimator, name, **kwargs):

    code = m2cgen.export_to_c(estimator)

    n_classes = len(estimator.classes_)
    dtype = 'int16_t'

    code += f'''\n
    int {name}_predict(const {dtype} *features, int length) {{
        const int n_classes = {n_classes};
        double outputs[{n_classes}] = {{0.0}};
        double inputs[length];
        
        for (int i=0; i<length; i++) {{
            inputs[i] = features[i];
        }}

        score(inputs, outputs);

        // argmax
        double best_score = 0.0;
        int best_index = 0;
        for (int i=0; i<n_classes; i++) {{
            const double s = outputs[i];
            if (s > best_score) {{
                best_score = s;
                best_index = i;
            }}
        }}

        //printf("predict class=%d \\n", best_index);
        return best_index;
    }}'''

    return code

def export_micromlgen(estimator, name, **kwargs):

    code = micromlgen.port(estimator)

    code += f'''\n
    extern "C" {{

    int {name}_predict(const int16_t *features, int length) {{

        float conv[length];
        for (int i=0; i<length; i++) {{
            conv[i] = features[i];
        }}

        Eloquent::ML::Port::RandomForest forest;
        const int out = forest.predict(conv);

        return out;
    }}

    }}
    '''

    return code

def export_dummy(estimator, name, **kwargs):

    code = f"""
    int {name}_predict(const int16_t *features, int length) {{

        double conv[length];
        for (int i=0; i<length; i++) {{
            conv[i] = features[i];
        }}

        const int out = (int)(conv[length-1] > 0.5f);
        return out;
    }}
    """

    return code

def generate_test_data(X, Y):

    assert len(X) == len(Y)
    n_features = X.shape[1]

    code = '// Generated by compare_frameworks.py'
    X_flat = list(X.flatten(order='C'))
    code += '\n' + array_declare('testdata_values', values=X_flat, dtype='int16_t')

    code += '\n' + array_declare('testdata_labels', values=Y, dtype='int')
    code += '\n' + constant_declare('testdata_samples', len(X))
    code += '\n' + constant_declare('testdata_features', n_features)

    return code

exporters = {
    'emlearn': export_emlearn,
    'm2cgen': export_m2cgen,
    'micromlgen': export_micromlgen,
    'none': export_dummy,
}

def main():

    # Inference code for each framework. One file per framework. Defines predict function
    # Test program. Macros to select a framework.

    # One directory per model
    # Select N models, of various sizes, for each dataset

    out_dir = 'code'
    estimator_path = sys.argv[1]
    data_path = estimator_path.replace('.estimator.pickle', '.testdata.npz')

    # Load inputs
    testdata = numpy.load(data_path, allow_pickle=True)

    with open(estimator_path, 'rb') as f:
        estimator = pickle.load(f)

    if not os.path.exists(out_dir):
        os.makedirs(out_dir)

    # Convert classifiers to C
    for k, exporter in exporters.items():

        p = os.path.join(out_dir, f'model_{k}.h')
        code = exporter(estimator, 'model')
        with open(p, 'w') as f:
            f.write(code)

    # Transform class names to indices
    class_name_to_index = {}
    class_index_to_name = {}
    for i, c in enumerate(estimator.classes_):
        class_name_to_index[c] = i
        class_index_to_name[i] = c
    Y = pandas.Series(testdata['Y']).map(class_name_to_index)

    X = testdata['X']

    data = generate_test_data(X, Y)
    with open(os.path.join(out_dir, 'testdata.h'), 'w') as f:
        f.write(data)


    #data = get_program_size(test_program, platform=platform, mcu=mcu)

    #return pandas.Series(data)



if __name__ == '__main__':
    main()
